<!-- C Primer Plus学习笔记 -->
<!-- omit in TOC -->
# C Primer Plus学习笔记


# 目录
- [目录](#目录)
- [概述](#概述)
- [第一部分](#第一部分)
  - [第一章：初识C语言](#第一章初识c语言)
  - [第二章：C语言概述](#第二章c语言概述)
  - [第三章：数据和C](#第三章数据和c)
  - [第四章 字符串和格式化输入/输出](#第四章-字符串和格式化输入输出)
    - [前述相关知识](#前述相关知识)
- [Part Two](#part-two)


# 概述
本笔记是《C primer plus》的学习笔记，自2021.07.09起。  

参考书目：
- 《C Primer Plus（第六版）中文版》。\[美\]史蒂芬·普拉达著，姜佑译。人民邮电出版社。
- 《C Primer Plus（第六版）中文版习题解答》。\[美\]史蒂芬·普拉达著，曹良亮编。人民邮电出版社。
- 《C Primer Plus (6th Edition)》，全两册。\[美\]史蒂芬·普拉达著，曹良亮编。人民邮电出版社。

# 第一部分

## 第一章：初识C语言
> 由于本章比较简单，部分内容直接略去。  
1. 解决程序执行完毕后，执行程序的窗口立即消失：`return 0;` 语句前插入 `getchar();` 或 `getchar(); getchar();` 
> 按理说一次 `getchar();` 足矣，但有时前语句中可能有类似 `scanf()` 的函数，此时一个 `getchar();` 读取到的可能只是用户为该函数而输入的<kbd>Enter</kbd>

## 第二章：C语言概述
> 由于本章比较简单，部分内容直接略去。  
1. 关键词(keyword)：如 `int`, `signed` 等。  
  标识符(identifier)：如各种变量名等。 
  保留标识符(reserved identifier)：以下划线开头的标识符和库函数名，不能用于变量名。如 `printf` 等。 
    - [ ] `Bool` / `_Bool` 不能使用？

## 第三章：数据和C
> 由于本章比较简单，部分内容直接略去。  
1. 储存单元：  
    - **位(bit)：** 一个开/关
    - **字节(byte)：** *一般应该定义为8位（8bit）*  
      &emsp; <u>**但是：C语言将字节定义为`char`类型占用的bit数，因此在每个环境下是不一样的。**</u>  
      &emsp; **`char`类型占用的bit数：** 与编码直接相关，比如*ASCII*、增补的*ASCII*等8位\(8bit\)足够\(2\^8=256\)，而比如*utf-8*，需要8\~32位(8\~32bit)。  
    - **字(word)：** 这里指**机器字长**。设计计算机时给定的自然存储单位。比如早期的8位，16位CPU和如今常见的32位，64位CPU。
      > 拓展阅读：
      >   1. <details><summary>字与字长</summary>
      >      &emsp;<strong>字(Word)：</strong>在计算机中作为一个整体被存取、传送、处理的一组二进制数。<br/>
      >      &emsp;<strong>字长(Word Size)：</strong>字所占的比特数。<br/>
      >      &emsp;<strong>例如：</strong>8位的操作系统，<i>字长</i>是8位，<code>01010101</code>可以是该操作系统的一个<i>字</i>。
      >      </details>
      >   2. <details>
      >      <summary>机器字长、存储字长、指令字长、数据字长</summary>
      >      &emsp;<strong>机器字长：</strong>CPU一次能处理数据的位数，通常与CPU的寄存器位数有关。<br/>
      >      &emsp;<strong>存储字长：</strong>存储器中一个存储单元(存储地址)所存储的二进制代码的位数，即存储器中的MDR的位数。<br/>
      >      &emsp;<strong>指令字长：</strong>计算机指令字的位数。<br/>
      >      &emsp;<strong>数据字长：</strong>一段数据存储所占用的位数。<br/>
      >      &emsp;&emsp;<i>注：</i><br/>  
      >      &emsp;&emsp;&emsp;1. 通常早期计算机：存储字长=指令字长=数据字长。故访问一次便可取一条指令或一个数据，随着计算机应用范围的不断扩大，三者可能各不相同，但它们必须是字节的整数倍。<br/>
      >      &emsp;&emsp;&emsp;2. 冯诺依曼机中，指令和数据同等重要，都存放在存储器中，并可按地址寻访。<br/>
      >      &emsp;&emsp;&emsp;3. 为了适应不同的要求及协调运算精度和硬件造价间的关系，大多数计算机均支持变字长运算，即机内可实现半字长、全字长（或单字长）和双倍字长运算。
      >      </details>
  1. 初始化变量：  
      初始化变量 **不能** 和不需初始化的变量一起声明。如：
      ```C
      int cat,dog;
      cat=1;
      dog=2;               //以上写法完全正确

      int cat=1;
      int dog=2;           //以上写法也正确

      int cat=1,dog=2;     //以上写法错误，实际只初始化了cat，初始化dog没有成功
      ```
  3. 整数类型
      - 进制
      - short, int, long, long long 
        1. 现在个人计算机上常见的设置是
         
            类型|位数
            ---|---
            `short`|16
            `int`|16/32
            `long`|32
            `long long`|64
        3. 选取适当的整数类型：
           - 位数超过时，首先考虑是否能用`unsigned`；
           - 在`long`和`int`占位相同的系统上编写代码，在数据超过16位时，应当使用`long`，避免移植后数据溢出；
           - `short`类型一般只用于程序较系统很大，或者硬件寄存器是16位；否则用`int`类型无大碍。
        1. 默认常量的类型和指定特定类型  
            &emsp; 通常程序代码中使用的数字会被储存为`int`类型，超过范围时，依次尝试`long`、`unsigned long`、`long long`和`unsigned long long`。（注意，可能不会自动尝试`unsigned int`）  
            &emsp; 有时存储一个小数据但希望它被认为成占位多的类型（比如存储地址），可以通过后缀`L`(或`l`)，`LL`(或`ll`)，`U`(或`u`) 分别指定改常量为`long`，`long long`，`unsigned`。可以搭配使用，无前后顺序要求。e.g.`12ULL`，`33LLU`
            > 注意：尽管`l`和`ll`可以使用，为了避免与`1`混淆，通常建议使用大写。
  4. *"字符"* 类型
      > 注意：尽管`char`类型用来存储字符，但从技术层面上来看，`char`应该被认为是一种整数类型。
      1. 初始化：  
          &emsp; 基础语法如 `char a; a='A'` 。然而奇怪的是，在C语言中，字符常量（如'A'）是以 `int` 类型存储的。因此，如果有一个 `int` 为32位， `char` 为8位的操作系统，我们可以找一个空间储存4个字符，赋值给 `char` 类型变量时，会等同于用最后一个字符赋值。如下图
          ![字符常量赋值给`char`类型](408\0_C\sources\C Primer Plus\CharInitialization.png) 
          - [ ] 程序有一个奇怪的问题，用 `'NFATE'`赋值时，因为 `int` 类型只能接受4个8位字符，故 `'N'` 会被丢弃，但是 `>>32` 应该得到`0`不是吗？
      3. 非打印字符和转义序列(escape sequence)：  
          - 警报字符：如 `\a` 。C语言规定警报字符不能改变活跃位置。  
            >  活跃位置（*active position*）：指的是显示设备中下一个字符将出现的位置，即光标位置。
          - 输出设备控制字符。如：`\n`。输出设备控制字符不一定在所有的显示设备上都生效，甚至有可能生成乱码，只有输出到打印机才有应有效果。
          - 打印字符也可以转义。打印字符时可以使用如 `\x41`（16进制41），`\101`（8进制101）来打印字符 `A`（10进制65）
      4. 最新标准允许 `unsigned char`
  5. 布尔类型 `_Bool`：原则上也是一种整数类型，但只占1位
  6. 可移植类型：C99新增了两个头文件 `stdint.h` 和 `inttypes.h` 
      - `stdint.h`：创建了更多的类型名（称为精确宽度整数类型 *exact-width integer type*），并将新类型名作为别名。如 `int_32` 类型作为 `int` 为32位系统中 `int` 的别名，而在 `int` 为16位，`long`为32位的系统中作为 `long` 的别名，来增强可移植性。
      - `inttypes.h`：由于精确宽度整数类型是可选项，底层可能不支持。故 `inttypes.h` 在 `stdint.h` 的基础上定义了最小宽度类型 *minimum width type* 和 最快最小宽度类型 *fastest minimum width type*。最小宽度类型（如：`int_least8_t`） 可以保证系统至少用8位的空间处理此变量。最快最小宽度类型（如：`int_fast8_t`）可以使系统寻找一种可以容纳8位，同时又是容纳8位的最小的数据类型。
      - 针对输入输出 `stdint.h` 和 `inttypes.h` 定义了多个宏（如： `PRId32`）来代替 `%` 后的字符。预处理指令会帮助宏转变为正确的转换说明。
1. 浮点类型。
      

<br/>

## 第四章 字符串和格式化输入/输出

### 前述相关知识
1. 【@错误】`printf()`参数数目不匹配，如：  
      &emsp; &emsp; `printf("%d%d",a);`  
      &emsp; 程序中包含两个*转换说明*，但参数只提供了一个。
      > **注意：** 由于`printf()`函数设计独特，尽管参数不足，但<u>**编译器不会报错或警告！！！**</u>
3. 【@错误】强行转变格式，忽略*溢出*、`unsigned`等潜在问题。
4. 非打印字符
5. char两种输出，字符和整数


# Part Two



