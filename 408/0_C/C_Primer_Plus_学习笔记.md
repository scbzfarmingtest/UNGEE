<!-- C Primer Plus学习笔记 -->
<!-- omit in TOC -->
# C Primer Plus学习笔记


# 目录
- [目录](#目录)
- [概述](#概述)
- [第一部分](#第一部分)
  - [第一章：初识C语言](#第一章初识c语言)
  - [第二章：C语言概述](#第二章c语言概述)
  - [第三章：数据和C](#第三章数据和c)
  - [第四章 字符串和格式化输入/输出](#第四章-字符串和格式化输入输出)
    - [前述相关知识](#前述相关知识)
- [Part Two](#part-two)


# 概述
本笔记是《C primer plus》的学习笔记，自2021.07.09起。  

参考书目：
- 《C Primer Plus（第六版）中文版》。\[美\]史蒂芬·普拉达著，姜佑译。人民邮电出版社。
- 《C Primer Plus（第六版）中文版习题解答》。\[美\]史蒂芬·普拉达著，曹良亮编。人民邮电出版社。
- 《C Primer Plus (6th Edition)》，全两册。\[美\]史蒂芬·普拉达著，曹良亮编。人民邮电出版社。

# 第一部分

## 第一章：初识C语言
> 由于本章比较简单，部分内容直接略去。  
1. 解决程序执行完毕后，执行程序的窗口立即消失：`return 0;` 语句前插入 `getchar();` 或 `getchar(); getchar();` 
> 按理说一次 `getchar();` 足矣，但有时前语句中可能有类似 `scanf()` 的函数，此时一个 `getchar();` 读取到的可能只是用户为该函数而输入的<kbd>Enter</kbd>

## 第二章：C语言概述
> 由于本章比较简单，部分内容直接略去。  
1. 关键词(keyword)：如 `int`, `signed` 等。  
  标识符(identifier)：如各种变量名等。 
  保留标识符(reserved identifier)：以下划线开头的标识符和库函数名，不能用于变量名。如 `printf` 等。 
    - [ ] `Bool` / `_Bool` 不能使用？

## 第三章：数据和C
> 由于本章比较简单，部分内容直接略去。  
1. 储存单元：  
    - **位(bit)：** 一个开/关
    - **字节(byte)：** *一般应该定义为8位（8bit）*  
      &emsp; <u>**但是：C语言将字节定义为`char`类型占用的bit数，因此在每个环境下是不一样的。**</u>  
      &emsp; **`char`类型占用的bit数：** 与编码直接相关，比如*ASCII*、增补的*ASCII*等8位\(8bit\)足够\(2\^8=256\)，而比如*utf-8*，需要8\~32位(8\~32bit)。  
    - **字(word)：** 这里指**机器字长**。设计计算机时给定的自然存储单位。比如早期的8位，16位CPU和如今常见的32位，64位CPU。
      > 拓展阅读：
      >   1. <details><summary>字与字长</summary>
      >      &emsp;<strong>字(Word)：</strong>在计算机中作为一个整体被存取、传送、处理的一组二进制数。<br/>
      >      &emsp;<strong>字长(Word Size)：</strong>字所占的比特数。<br/>
      >      &emsp;<strong>例如：</strong>8位的操作系统，<i>字长</i>是8位，<code>01010101</code>可以是该操作系统的一个<i>字</i>。
      >      </details>
      >   2. <details>
      >      <summary>机器字长、存储字长、指令字长、数据字长</summary>
      >      &emsp;<strong>机器字长：</strong>CPU一次能处理数据的位数，通常与CPU的寄存器位数有关。<br/>
      >      &emsp;<strong>存储字长：</strong>存储器中一个存储单元(存储地址)所存储的二进制代码的位数，即存储器中的MDR的位数。<br/>
      >      &emsp;<strong>指令字长：</strong>计算机指令字的位数。<br/>
      >      &emsp;<strong>数据字长：</strong>一段数据存储所占用的位数。<br/>
      >      &emsp;&emsp;<i>注：</i><br/>  
      >      &emsp;&emsp;&emsp;1. 通常早期计算机：存储字长=指令字长=数据字长。故访问一次便可取一条指令或一个数据，随着计算机应用范围的不断扩大，三者可能各不相同，但它们必须是字节的整数倍。<br/>
      >      &emsp;&emsp;&emsp;2. 冯诺依曼机中，指令和数据同等重要，都存放在存储器中，并可按地址寻访。<br/>
      >      &emsp;&emsp;&emsp;3. 为了适应不同的要求及协调运算精度和硬件造价间的关系，大多数计算机均支持变字长运算，即机内可实现半字长、全字长（或单字长）和双倍字长运算。
      >      </details>
  1. 初始化变量：  
      初始化变量 **不能** 和不需初始化的变量一起声明。如：
      ```C
      int cat,dog;
      cat=1;
      dog=2;               //以上写法完全正确

      int cat=1;
      int dog=2;           //以上写法也正确

      int cat=1,dog=2;     //以上写法错误，实际只初始化了cat，初始化dog没有成功
      ```
  3. 整数类型
      - 进制
      - short, int, long, long long 
        1. 现在个人计算机上常见的设置是
         
            类型|位数
            ---|---
            `short`|16
            `int`|16/32
            `long`|32
            `long long`|64
        3. 选取适当的整数类型：
           - 位数超过时，首先考虑是否能用`unsigned`；
           - 在`long`和`int`占位相同的系统上编写代码，在数据超过16位时，应当使用`long`，避免移植后数据溢出；
           - `short`类型一般只用于程序较系统很大，或者硬件寄存器是16位；否则用`int`类型无大碍。
        1. 默认常量的类型和指定特定类型  
            &emsp; 通常程序代码中使用的数字会被储存为`int`类型，超过范围时，依次尝试`long`、`unsigned long`、`long long`和`unsigned long long`。（注意，可能不会自动尝试`unsigned int`）  
            &emsp; 有时存储一个小数据但希望它被认为成占位多的类型（比如存储地址），可以通过后缀`L`(或`l`)，`LL`(或`ll`)，`U`(或`u`) 分别指定改常量为`long`，`long long`，`unsigned`。可以搭配使用，无前后顺序要求。e.g.`12ULL`，`33LLU`
            > 注意：尽管`l`和`ll`可以使用，为了避免与`1`混淆，通常建议使用大写。
  4. *"字符"* 类型
      > 注意：尽管`char`类型用来存储字符，但从技术层面上来看，`char`应该被认为是一种整数类型。
      
      1. 初始化：  
          &emsp;  
      3. 
  5. 
      

 <br/>

 ## 第四章 字符串和格式化输入/输出

 ### 前述相关知识
 1. 【@错误】`printf()`参数数目不匹配，如：  
      &emsp; &emsp; `printf("%d%d",a);`  
      &emsp; 程序中包含两个*转换说明*，但参数只提供了一个。
      > **注意：** 由于`printf()`函数设计独特，尽管参数不足，但<u>**编译器不会报错或警告！！！**</u>
 3. 【@错误】强行转变格式，忽略*溢出*、`unsigned`等潜在问题。
 4. 非打印字符



# Part Two



